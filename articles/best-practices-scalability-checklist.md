<properties
   pageTitle="Schaalbaarheid controlelijst | Microsoft Azure"
   description="Schaalbaarheid controlelijst richtlijnen voor het ontwerpen bezwaren voor Azure Autoscaling."
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="christb"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="07/13/2016"
   ms.author="masashin"/>

# <a name="scalability-checklist"></a>Schaalbaarheid controlelijst

[AZURE.INCLUDE [pnp-header](../includes/guidance-pnp-header-include.md)]

## <a name="service-design"></a>Service-ontwerp
- **Partition de werklast**. Onderdelen van het proces aparte en decomposable ontwerpen. De grootte van elk onderdeel, terwijl de gebruikelijke regels voor scheiding van bezwaren en het principe één verantwoordelijkheid minimaliseren. Hierdoor wordt de onderdelen moet worden verdeeld op een manier die gemaximaliseerd gebruik per eenheid berekenen (zoals een rol of database-server). Deze ook vergemakkelijkt de schaal van de toepassing aanpassen door toe te voegen exemplaren van specifieke resources. Zie [Richtlijnen voor partitioneren berekenen](https://msdn.microsoft.com/library/dn589773.aspx)voor meer informatie.
- **Ontwerp voor schaalbaarheid**. Schaalbaarheid geeft-toepassingen om te reageren op variabele laden maken door te vergroten en verkleinen van het aantal exemplaren van rollen, wachtrijen en andere services die ze gebruiken. De toepassing moet echter met deze zijn ontworpen mee. Bijvoorbeeld de toepassing en de site gebruikmaakt van services moeten stateless, toe te staan dat aanvragen naar een willekeurig exemplaar worden doorgestuurd. Hiermee voorkomt u ook het toevoegen of verwijderen van de exemplaren die specifieke nadelig beïnvloeden actieve gebruikers. U moet ook implementeren configuratie of automatische detectie van de exemplaren die als ze worden toegevoegd of verwijderd, zodat code in het programma met de benodigde routering uitvoeren kunt. Een webtoepassing mogelijk een set wachtrijen bijvoorbeeld gebruiken in een aanpak round robin verzoeken om om te leiden Achtergrondservices worden uitgevoerd in werknemer rollen. De webtoepassing moet kunnen detecteren van wijzigingen in het aantal wachtrijen voor het routeren van aanvragen en saldo vanaf de belasting van de toepassing.
- **Schaal als een eenheid**. Plan voor aanvullende informatie voor de groei. Voor elke resource, de rechterbovenhoek schaalbaarheid limieten weten en gebruik sharding of uitgevouwen naar een stapje verder dan deze limieten. Hiermee bepaalt u de schaaleenheden voor het systeem met goed gedefinieerde sets met resources. Hierdoor toepassen schalen bewerkingen gemakkelijker en minder vatbaar voor negatieve invloed op de toepassing tot en met beperkingen door gebrek aan resources in een deel van de algehele systeemprestaties. Bijvoorbeeld, toe te voegen x aantal web en werknemer rollen kan het nodig zijn y aantal aanvullende wachtrijen en z-nummer opslag accounts u omgaat met de extra werklast gegenereerd door de rollen. Zodat een eenheid voor tijdschaal kan bestaan uit x web en werknemer rollen, _y_ wachtrijen en _z_ -opslag-accounts. De toepassing ontwerpen zodat deze eenvoudig door toe te voegen een of meer schaaleenheden wordt aangepast.
- **Vermijd clientaffiniteit**. Zorg ervoor dat er geen affiniteit is vereist voor de toepassing indien mogelijk. Aanvragen kunnen dus worden doorgestuurd naar een willekeurig exemplaar en het aantal exemplaren die niet relevant is. Zo voorkomt u ook de realiseren van opslaan, ophalen en onderhouden van informatie over de status voor elke gebruiker.
- **Profiteren van platform autoscaling functies**. Waar de host-platform ondersteuning biedt voor een mogelijkheid autoscaling, zoals Azure automatisch schalen, wilt u deze aangepaste of derden regelingen tenzij de ingebouwde om kan niet voldoen aan uw vereisten voor. Regels voor geplande schaal gebruiken waar mogelijk om ervoor te zorgen resources zijn beschikbaar zonder een vertraging opstart, maar reactieve autoscaling toevoegen aan de regels eventueel omgaan met onverwachte wijzigingen in de aanvraag. Om aan te passen autoscaling en aangepaste tellers toevoegen aan regels, kunt u de autoscaling bewerkingen in de API voor het beheer van Service. Zie [automatisch schalen richtlijnen](best-practices-auto-scaling.md)voor meer informatie.
- **Offload intensief CPU/IO taken als achtergrondtaken**. Als u een verzoek om een service wordt verwacht erg lang duren wilt uitvoeren of aanzienlijke resources absorbeert, offload u dit verzoek aan een taak afzonderlijk worden verwerkt. Gebruik werknemer rollen of achtergrondtaken (afhankelijk van de host-platform) deze taken uitvoeren. Deze strategie kunt de service blijven ontvangen verder aanvragen en blijven heeft gereageerd.  Zie [achtergrond taken richtlijnen](best-practices-background-jobs.md)voor meer informatie.
- **De werklast voor achtergrondtaken verdelen**. Waar zijn er veel achtergrondtaken of als de taken aan veel tijd of resources, Verdeel de werklast over meerdere berekeningscluster (zoals werknemer rollen of achtergrondtaken). Zie het [Patroon van consumenten dat](https://msdn.microsoft.com/library/dn568101.aspx)voor een mogelijke oplossing.
- **? Probeer te verplaatsen naar een _gedeeld niets_ architectuur**. Een gedeeld architectuur gebruikt onafhankelijke, vergaderverzoeken verwerken knooppunten waarvoor geen potentieel van een conflict (zoals gedeelde services of opslag). Een dergelijk systeem kan in theorie vrijwel voor onbepaalde tijd schalen. Terwijl een aanpak volledig gedeeld-over het algemeen niet praktisch haalbaar voor de meeste toepassingen is, kan het zijn dat hierin verkoopkansen voor betere schaalbaarheid ontwerpen. Bijvoorbeeld het gebruik van de status van de serverzijde sessie voorkomen, clientaffiniteit en partitioneren van gegevens zijn goede voorbeelden van de richting van de architectuur van een gedeeld verplaatsen.

## <a name="data-management"></a>Gegevensbeheer

- **Gebruik gegevens partitioneren**. De gegevens delen op meerdere databases en databaseservers of ontwerpen voor gegevensopslag services die kunt dit partitioneren transparant (voorbeelden hiervan zijn Azure SQL Database elastische Database en Azure-tabelopslag). Deze methode kunt prestaties en gemakkelijker schaalbaarheid toestaan. Er zijn verschillende technieken, zoals horizontale, verticale, partitioneren en functionele. U kunt een combinatie van deze gebruiken om te profiteren van betere queryprestaties, eenvoudiger schaalbaarheid, flexibeler management, betere beschikbaarheid bereiken en zodat deze overeenkomt met het type archief tot de gegevens die mogelijk is. Bovendien kunt u verschillende soorten gegevensopslag gebruiken voor verschillende soorten gegevens, de typen op basis van hoe goed ze zijn geoptimaliseerd voor het soort gegevens te kiezen. Dit kan ook met tabelopslag, een document-database of een kolom-reeks gegevensopslag, in plaats van, of en als, een relationele database. Zie [gegevens partities richtlijnen](best-practices-data-partitioning.md)voor meer informatie.
- **Ontwerp voor eventuele consistentie**. Uiteindelijke consistentie verbetert schaalbaarheid door verkleinen of te verwijderen van de tijd die nodig is om gerelateerde gegevens in meerdere archieven partitioneren te synchroniseren. De kosten is dat gegevens niet altijd consistente wanneer deze wordt gelezen en enkele schrijven bewerkingen conflicten kunnen veroorzaken. Uiteindelijke consistentie is ideaal voor situaties waarin dezelfde gegevens is vaak lezen maar niet vaak worden geschreven. Zie de [Gegevens consistentie handleiding](https://msdn.microsoft.com/library/dn589800.aspx)voor meer informatie.
- **Verkleinen chatty interacties tussen onderdelen en -services**. Voorkomen dat het ontwerpen van interacties waarin een toepassing is vereist voor meerdere gesprekken te voeren naar een service (elk retourneert een kleine hoeveelheid gegevens), in plaats van één aanroep waarmee de gegevens kunt geretourneerd. Indien mogelijk, combineert u verschillende gerelateerde bewerkingen in één aanvraag wanneer het gesprek is aan een service of het onderdeel dat opvallend latentie heeft. Zo makkelijker prestaties bewaken en optimaliseren van complexe bewerkingen. Bijvoorbeeld via opgeslagen procedures in databases onderbrengen complexe logica en Beperk het aantal interactie en resource vergrendelen.
- **Gebruik wachtrijen als u wilt de belasting voor hoge snelheid gegevens schrijft effenen**. Piekspanningen in de aanvraag voor een service kunnen overspoeld van die service en groeiende fouten veroorzaken. Om dit te voorkomen, kunt u de [wachtrij gebaseerde laden herverdelen patroon](https://msdn.microsoft.com/library/dn589783.aspx)implementeren. Gebruik een wachtrij die fungeert als buffer tussen een taak en een service die deze activeert. Dit kan door onregelmatige dik laadtijd die anders veroorzaken kunnen de service mislukt of de taak time-out vloeiend.
- **Minimaliseren de belasting op de gegevensopslag**. De store gegevens is meestal een verwerking vertraging veroorzaken, een dure resource, en niet vaak eenvoudig aan de nieuwe schaal af. Indien mogelijk, logica (zoals het verwerken van XML-documenten of JSON objecten) verwijderen uit de gegevensopslag en verwerking binnen de toepassing uitvoeren. Bijvoorbeeld in plaats van het doorgeven van XML in de database (andere dan als één tekenreeks voor opslag), serialiseren of terugconverteren van de XML-gegevens in de toepassingslaag en deze in een formulier dat bij de gegevensopslag. Het is meestal veel gemakkelijker is naar de schaal van de toepassing dan de gegevensopslag, zodat u proberen beter te doen als veel van de verwerking computerintensieve mogelijk in de toepassing.
- **Minimaliseer het volume van de gegevens zijn opgehaald**. Alleen de gewenste door te geven kolommen en het gebruik van criteria voor het selecteren van rijen gegevens ophalen. Maak gebruik van de parameters voor waarde en de juiste isolatieniveau. Gebruik regelingen zoals entiteit tags om te voorkomen onnodig ophalen van gegevens.
- **Serieus gebruiken in cache opslaan**. Gebruik zoveel mogelijk verkleinen van de belasting van resources en services die genereren of gegevens leveren caching. Caching is meestal geschikt voor de gegevens die is relatief statische of die is vereist aanzienlijke verwerking om te verkrijgen. Caching moet worden uitgevoerd op alle niveaus eventueel in elke laag die u van de toepassing, inclusief gegevens access en gebruiker interface generatie. Zie de [Richtlijnen in cache opslaan](best-practices-caching.md)voor meer informatie.
- **Gegevensgroei en het bewaarbeleid verwerken**. De hoeveelheid gegevens die zijn opgeslagen door een toepassing in omvang groeit na verloop van tijd. Deze groei verhogen opslagkosten en latentie verhogen bij het openen van de gegevens, die van invloed is op toepassing doorvoer en prestaties. Het is mogelijk dat deze regelmatig enkele van de oude gegevens die niet meer wordt geraadpleegd archiveren of verplaatsen van gegevens die toegankelijk is zelden naar langdurige opslag die meer kosten efficiënte, zelfs als de access-latentie hoger is.
- **Optimaliseren Data overbrengen Objects (DTOs) met een efficiënte binaire indeling**. DTOs worden doorgegeven tussen de lagen van een toepassing vaak. De grootte minimaliseren, wordt de belasting van resources en het netwerk. Echter saldo vanaf het verschil in omvang door met de realiseren van de gegevens te converteren naar de juiste opmaak op elke locatie waar deze worden gebruikt. Een indeling die is de maximale interoperabiliteit om in te schakelen eenvoudig hergebruik van een onderdeel vast.
- **Cache-besturingselement instellen**. Ontwerp en de toepassing configureren voor gebruik uitvoercaching van of fragment caching indien mogelijk, om te minimaliseren verwerking laden.
- **Caching aan clientzijde inschakelen**. Webtoepassingen moeten cache-instellingen op de inhoud die kan worden opgeslagen in de cache inschakelen. Dit is meestal standaard uitgeschakeld. Configureer de server om de juiste cache besturingselement kopteksten om in te schakelen in cache opslaan van inhoud op proxyservers en -clients.
- **Gebruik Azure-blobopslag en het Azure inhoud bezorging netwerk verkleinen van de belasting van de toepassing**. Houd rekening met statische of relatief statische openbare inhoud, zoals afbeeldingen, resources, scripts en opmaakmodellen, in blobopslag opslaan. Deze methode brengt de toepassing van de belasting die worden veroorzaakt door deze inhoud voor elk verzoek om een dynamisch te genereren. Let op het gebruik van het netwerk van de bezorging van inhoud voor dit inhoudstype in cache en ervoor zorgen dat deze clients. Met het netwerk van de bezorging van inhoud kan de prestaties op de client verbeteren, omdat de inhoud van het geografisch dichtstbijzijnde datacenter met een cache inhoud bezorging netwerk is afgeleverd. Zie de [Richtlijnen van inhoud bezorging netwerk](best-practices-cdn.md)voor meer informatie.
- **Optimaliseren en verfijnen SQL-query's en indexen**. Sommige T-SQL-instructies of constructies mogelijk meteen invloed hebben op prestaties die kan worden verminderd door het optimaliseren van de code in een opgeslagen procedure. Bijvoorbeeld geen **datetime** typen converteren naar een **varchar** voordat vergelijken met een letterlijke **datetime** -waarde. Functies voor datum/tijd-vergelijking gebruiken. Uitvoering van de query kan ook vertraagd raken gebrek aan de juiste indexen. Als u een object/relationele toewijzing framework gebruikt, begrijpen hoe het werkt en hoe deze invloed kan zijn op prestaties van de data access-laag. Zie [Query optimaliseren](https://technet.microsoft.com/library/ms176005.aspx)voor meer informatie.
- **Overweeg opgeheven normaliseren gegevens**. Gegevens normaliseren helpt om te voorkomen kopiëren en deze niet gelijk zijn. Meerdere indexen onderhouden, controleren op referentiële integriteit, uitvoering van meerdere toegang tot kleine delen van gegevens, en deelnemen aan tabellen om de gegevens opnieuw legt echter een realiseren die invloed kan zijn op de prestaties. Houd rekening met als enkele extra opslagruimte volume en dubbel acceptabel om te verkleinen van de belasting van de store gegevens is. Bedenk ook als de toepassing zelf (dit is meestal gemakkelijker aan de nieuwe schaal) kan worden vertrouwd taken zoals het beheren van referentiële integriteit om te verkleinen van de belasting op de gegevensopslag overnemen. Zie [gegevens partities richtlijnen](https://github.com/mspnp/azure-guidance/blob/master/Data%20partitioning.md)voor meer informatie.

## <a name="service-implementation"></a>Service-implementatie
- **Gebruik asynchrone oproepen**. Asynchroon code zoveel mogelijk gebruikt als toegang tot resources of services die kunnen worden beperkt door i/o- of netwerkbandbreedte of die een opvallend latentie, om te voorkomen de thread vergrendelen. Implementatie van asynchrone bewerkingen, gebruikt u [Op basis van een taak asynchroon patroon (tik)](https://msdn.microsoft.com/library/hh873175.aspx).
- **Voorkom resources, vergrendelen en gebruikt u een optimistische werkwijze in plaats daarvan**. Nooit vergrendelen toegang tot bronnen zoals opslag of andere diensten die er opvallend latentie, omdat dit een primaire oorzaak van slechte prestaties is. Gebruik altijd optimistische benaderingen gelijktijdige bewerkingen uitvoeren, zoals het schrijven naar opslag beheren. Functies van de opslaglaag gebruiken voor het beheren van conflicten. In gedistribueerde toepassingen, gegevens mogelijk alleen uiteindelijk consistente.
- **Sterk gecomprimeerd gegevens over hoge latentie, netwerken met een lage bandbreedte comprimeren**. In de meeste gevallen in een webtoepassing wordt de grootste hoeveelheid gegevens gegenereerd door de toepassing en doorgegeven via het netwerk HTTP-antwoorden op aanvragen van clients. HTTP-compressie kunt verkleinen dit aanzienlijk, met name voor statische inhoud. Dit kunt kosten, evenals de belasting op het netwerk, wordt afgetrokken verkleinen Hoewel een fractie hoger laden dynamische inhoud op de server geldt. In een andere, meer generalized omgeving compressie kunt verkleinen van de hoeveelheid gegevens die worden verzonden en minimaliseren doorverbinden tijd en kosten, maar de processen compressie en decompressie realiseren oplopen. Compressie moet als zodanig alleen worden gebruikt als er een aantoonbare winst prestaties. Andere methoden serialisatie, zoals JSON of binaire coderingen, mogelijk verkleinen nettolading terwijl die kleiner is van invloed zijn op de prestaties, terwijl de XML kunnen vergroten deze is.
- **Minimaliseer het moment dat verbindingen en resources gebruikt worden**. Voor het behoud van verbindingen en bronnen alleen voor zo lang maken als u wilt gebruiken. Open bijvoorbeeld zo laat mogelijk verbindingen en hen teruggeleid naar de groep zo snel mogelijk in staat stellen. Zo laat mogelijk in het bezit van resources en buitengebruikstelling van deze zo snel mogelijk.
- **Minimaliseer het aantal verbindingen vereist**. Verbindingen met de service absorbeert resources. Het aantal die zijn vereist en zorg ervoor dat bestaande verbindingen opnieuw moet worden gebruikt wanneer dit mogelijk beperken. Bijvoorbeeld, na het uitvoeren van verificatie, gebruikt u imitatie eventueel code uit te voeren als een specifieke identiteit. Dit kan helpen optimaal gebruik van de resourcegroep die verbinding maken met het hergebruiken verbindingen.

    > [AZURE.NOTE]: APIs for some services automatically reuse connections, provided service-specific guidelines are followed. It's important that you understand the conditions that enable connection reuse for each service that your application uses.

- **Verzenden van aanvragen in batches optimaliseren netwerk gebruiken**. Bijvoorbeeld verzenden en gelezen berichten in batches bij het openen van een wachtrij en uitvoeren van meerdere lezen of schrijven als batch bij het openen van opslag of een cache. Dit kan helpen om het te optimaliseren van de services en gegevens winkels door te verminderen van het aantal oproepen via het netwerk.
- **Vermijd een vereiste om op te slaan serverzijde sessie staat** indien mogelijk. Aan de clientzijde staat sessiebeheer vereist meestal clientaffiniteit (die zich bevindt, elk verzoek om zoekresultaten omleiden naar de dezelfde server-instantie), die van invloed op de mogelijkheid van het systeem uit te breiden. In het ideale geval moet u clients kunnen geen status met betrekking tot de servers die ze gebruiken ontwerpen. Als de toepassing moet sessie stand, gevoelige gegevens op te slaan of grote hoeveelheden gegevens per-client in een gedistribueerde servers in cache die kunnen alle exemplaren van de toepassing benaderen.
- **Optimaliseren tabel opslag schema's**. Bij gebruik van de tabel bevat waarvoor u de tabel- en kolomnamen moet worden doorgegeven en verwerkt met elke query, zoals Azure-tabelopslag, kunt u overwegen kortere namen te deze realiseren. Echter niet ten koste leesbaarheid en beheerbaarheid die u met behulp van zeer compacte namen.
- **Gebruik de taak parallelle bibliotheek (TPL) asynchrone bewerkingen uit te voeren**. De TPL kunt u gemakkelijk te schrijven asynchroon code die ik/O-bewerkingen uitvoert. Gebruik _ConfigureAwait(false)_ zoveel mogelijk om zo de afhankelijkheid voortgezet op een specifieke synchronisatiecontext te onderdrukken. Dit is de kans op kleiner thread-deadlock optreedt.
- **De afhankelijke bronnen maken tijdens de implementatie of bij het opstarten van toepassing**. Voorkom herhaalde aanroepen van methoden dat de aanwezigheid van een bron testen en maak vervolgens de resource als deze nog niet bestaat. (Methoden zoals _CloudTable.CreateIfNotExists_ en _CloudQueue.CreateIfNotExists_ in de bibliotheek van Azure opslag Client Volg dit patroon). Deze methoden kunnen aanzienlijke belasting opleggen als ze worden aangeroepen vóór elke toegang tot een opslag tabel of de opslag wachtrij. In plaats daarvan:
 - De vereiste resources maken wanneer de toepassing wordt geïmplementeerd, of wanneer dit de eerste keer start (één aanroep _CreateIfNotExists_ voor elke resource in het opstartcode voor een rol web of werknemer acceptabel is). Echter, moet u uitzonderingen die zich voordoen kunnen als uw code verbinding probeert te maken van een resource die niet bestaat. In deze situaties, moet u de uitzondering Meld en mogelijk Waarschuw een operator waarop een resource verdwenen is.
 - Onder bepaalde omstandigheden kan zijn geschikt zijn voor het maken van de ontbrekende resource als onderdeel van de code verwerking van uitzonderingen. Maar u moet deze methode voorzichtig vast als het niet-bestaan van de resource is mogelijk indicatieve van een programming fout (bijvoorbeeld een verkeerd gespelde resourcenaam), of enkele andere infrastructuur niveau-probleem.
- **Gebruik lightweight kaders**. Kies zorgvuldig de API's en -kaders die u gebruikt om te minimaliseren Resourcegebruik, tijd en belasting van de toepassing. Bijvoorbeeld gebruik van Web API voor het afhandelen van serviceaanvragen kunt Beperk de toepassing op het milieu en snelheid van uitvoering vergroten, maar het is het niet mogelijk geschikt voor geavanceerde scenario's waarin de extra mogelijkheden van Windows Communication Foundation vereist zijn voor.
- **Overweeg het aantal serviceaccounts minimaliseren**. Bijvoorbeeld, gebruikt u een specifieke account voor toegang tot bronnen of services die hebben een limiet op verbindingen of uitvoeren beter waar minder verbindingen worden beheerd. Deze methode werkt het algemene voor services zoals databases, maar dit invloed kan zijn op de mogelijkheid om te bewerkingen vanwege de imitatie van de oorspronkelijke gebruiker nauwkeurig controleren.
- **Verricht prestaties profiel- en testen van laden** tijdens de ontwikkeling, als onderdeel van test routines en vóór de definitieve versie om ervoor te zorgen dat de toepassing wordt uitgevoerd en schaal zoals vereist. Deze testen op hetzelfde type hardware als het platform productie en met dezelfde opmaaktypen moet worden uitgevoerd en de hoeveelheid gegevens en de gebruiker zoals deze in productie ondervinden zullen geladen. Zie [testen van de prestaties van een cloudservice](vs-azure-tools-performance-profiling-cloud-services.md)voor meer informatie.
